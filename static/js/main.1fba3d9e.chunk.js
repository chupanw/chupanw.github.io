(this.webpackJsonphomepage=this.webpackJsonphomepage||[]).push([[0],{16:function(e){e.exports=JSON.parse('[{"title":"VarFix: Balancing Edit Expressiveness and Search Effectiveness in Automated Program Repair","authors":["Chu-Pan Wong","Priscila Santiesteban","Christian K\xe4stner","Claire Le Goues"],"year":"2021","publisher":"ACM","location":"Athens, Greece.","proceeding":"Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2021)","pages":"pages 354\u2013366","doi":"https://dl.acm.org/doi/abs/10.1145/3468264.3468600","pdf":"https://www.cs.cmu.edu/~chupanw/papers/varfix.pdf","abstract":"Automatically repairing a buggy program is essentially a search problem, searching for code transformations that pass a set of tests. Various search strategies have been explored, but they either navigate the search space in an ad hoc way using heuristics, or systemically but at the cost of limited edit expressiveness in the kinds of supported program edits. In this work, we explore the possibility of systematically navigating the search space without sacrificing edit expressiveness. The key enabler of this exploration is variational execution, a dynamic analysis technique that has been shown to be effective at exploring many similar executions in large search spaces. We evaluate our approach on IntroClassJava and Defects4J, showing that a systematic search is effective at leveraging and combining fixing ingredients to find patches, including many high-quality patches and multi-edit patches."},{"title":"Beyond Configurable Systems: Applying Variational Execution to Tackle Large Search Spaces","authors":["Chu-Pan Wong"],"year":"2021","proceeding":"PhD Dissertation","pdf":"https://www.cs.cmu.edu/~chupanw/thesis/thesis.pdf","abstract":"Variations are ubiquitous in software. Some variations are intentionally introduced, e.g., to provide extra functionalities or tweak certain program behavior, while some variations are speculatively generated to achieve certain search goals, such as mutating a buggy program to repair a bug. Although program variations provide great flexibility, their interactions are difficult to manage, as the number of possible interactions grows exponentially with the number of variations. There is increasing evidence showing the importance of studying interactions among variations in various domains, such as testing highly configurable systems, secure information flow tracking, higher-order mutation testing, and automatic program repair. In this thesis, we tackle large search spaces of interactions among variations."},{"title":"What It Would Take to Use Mutation Testing in Industry---A Study at Facebook","authors":["Moritz Beller","Chu-Pan Wong","Johannes Bader","Andrew Scott","Mateusz Machalica","Satish Chandra","Erik Meijer"],"proceeding":"Proceedings of the 2021 IEEE/ACM 43rd International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)","year":"2021","location":"Madrid, ES.","pages":"pages 268-277","publisher":"IEEE","arXiv":"https://arxiv.org/abs/2010.13464","doi":"https://doi.org/10.1109/ICSE-SEIP52600.2021.00036","video":"https://www.youtube.com/watch?v=dPhPr1nkRxU","abstract":"Traditionally, mutation testing generates an abundance of small deviations of a program, called mutants. At industrial systems the scale and size of Facebook\'s, doing this is infeasible. We should not create mutants that the test suite would likely fail on or that give no actionable signal to developers. To tackle this problem, in this paper, we semi-automatically learn error-inducing patterns from a corpus of common Java coding errors and from changes that caused operational anomalies at Facebook specifically. We combine the mutations with instrumentation that measures which tests exactly visited the mutated piece of code. Results on more than 15,000 generated mutants show that more than half of the generated mutants survive Facebook\'s rigorous test suite of unit, integration, and system tests. Moreover, in a case study with 26 developers, all but two found information of automatically detected test holes interesting in principle. As such, almost half of the 26 would actually act on the mutant presented to them by adapting an existing or creating a new test. The others did not for a variety of reasons often outside the scope of mutation testing. It remains a practical challenge how we can include such external information to increase the true actionability rate on mutants."},{"title":"Dissecting Strongly Subsuming Second-Order Mutants","authors":["Jo\xe3o P. Diniz","Chu-Pan Wong","Christian K\xe4stner","Eduardo Figueiredo"],"year":"2021","proceeding":"Proceedings of the 2021 14th IEEE Conference on Software Testing, Verification and Validation (ICST)","location":"Porto de Galinhas, Brazil.","publisher":"IEEE","pages":"pages 171-181","doi":"https://doi.org/10.1109/ICST49551.2021.00028","abstract":"Mutation testing is a fault-based technique commonly used to evaluate the quality of test suites in software systems. It consists of introducing syntactical changes, called mutations, into source code and checking whether the test cases distinguish them. Since there are dozens of distinct mutation types, one of the most challenging problems is the high computational effort required to test the whole test suite against each mutant. Since mutation testing is proposed, researchers have presented techniques aiming at effort reduction in the phases of its process. This study focuses on the potential reduction in the number of mutants provided by a special set of mutants generated by the introduction of two syntactical changes (strongly subsuming second-order mutants). In this work, we exhaustively searched for those second-order mutants. Our results show that they (i) are frequently generated by the expression removal mutation, (ii) are likely to be killed by the same test cases that kill their constituent mutants, and (iii) have the potential to reduce the number of mutants to be executed by about 22.3%."},{"title":"Efficiently Finding Higher-Order Mutants","authors":["Chu-Pan Wong","Jens Meinicke","Leo Chen","Jo\xe3o P. Diniz","Christian K\xe4stner","Eduardo Figueiredo"],"proceeding":"Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE)","year":"2020","pages":"pages 1165-1177","publisher":"ACM","location":"New York, NY, USA.","pdf":"https://www.cs.cmu.edu/~chupanw/papers/fse20.pdf","doi":"https://doi.org/10.1145/3368089.3409713","arXiv":"https://arxiv.org/abs/2004.02000","video":"https://youtu.be/ziiG_AWQj_8","abstract":"Higher-order mutation has the potential for improving major drawbacks of traditional first-order mutation, such as by simulating more realistic faults or improving test-optimization techniques. Despite interest in studying promising higher-order mutants, such mutants are difficult to find due to the exponential search space of mutation combinations. State-of-the-art approaches rely on genetic search, which is often incomplete and expensive due to its stochastic nature. First, we propose a novel way of finding a complete set of higher-order mutants by using variational execution, a technique that can, in many cases, explore large search spaces completely and often efficiently. Second, we use the identified complete set of higher-order mutants to study their characteristics. Finally, we use the identified characteristics to design and evaluate a new search strategy, independent of variational execution, that is highly effective at finding higher-order mutants even in large codebases."},{"title":"Exploring Differences and Commonalities between Feature Flags and Configuration Options","authors":["Jens Meinicke","Chu-Pan Wong","Bogdan Vasilescu","Christian K\xe4stner"],"year":"2020","proceeding":"Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering: Software Engineering in Practice (ICSE-NIER)","pages":"pages 233-242","publisher":"ACM","location":"Seoul, South Korea.","doi":"https://doi.org/10.1145/3377813.3381366","video":"https://youtu.be/8DfsVfiAkFI","pdf":"https://www.cs.cmu.edu/~chupanw/papers/icseseip20.pdf","abstract":"Feature flags for continuous deployment and configuration options for customizing software share many similarities, both conceptually and technically. However, neither academic nor practitioner publications seem to clearly compare these two concepts. We argue that a distinction is valuable, as applications, goals, and challenges differ fundamentally between feature flags and configuration options. In this work, we explore the differences and commonalities of both concepts to help understand practices and challenges, and to help transfer existing solutions (e.g., for testing). To better understand feature flags and how they relate to configuration options, we performed nine semi-structured interviews with feature-flag experts. We discovered several distinguishing characteristics but also opportunities for knowledge and technology transfer across both communities. Overall, we think that both communities can learn from each other."},{"title":"Faster Variational Execution with Transparent Bytecode Transformation","authors":["Chu-Pan Wong","Jens Meinicke","Lukas Lazarek","Christian K\xe4stner"],"proceeding":"Proceedings of the 33rd Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)","location":"Boston, MA, USA.","year":"2018","publisher":"ACM","pages":"Article 117, 30 pages","pdf":"https://www.cs.cmu.edu/~chupanw/papers/oopsla18.pdf","arXiv":"https://arxiv.org/abs/1809.04193","doi":"https://dl.acm.org/doi/10.1145/3276487","abstract":"Variational execution is a novel dynamic analysis technique for exploring highly configurable systems and accurately tracking information flow. It is able to e\ufb03ciently analyze many configurations by aggressively sharing redundancies of program executions. The idea of variational execution has been demonstrated to be effective in exploring variations in the program, especially when the configuration space grows out of control. Existing implementations of variational execution often require heavy lifting of the runtime interpreter, which is painstaking and error-prone. Furthermore, the performance of this approach is suboptimal. For example, the state-of-the-art variational execution interpreter for Java, VarexJ, slows down executions by 100 to 800 times over a single execution for small to medium size Java programs. Instead of modifying existing JVMs, we propose to transform existing bytecode to make it variational, so it can be executed on an unmodified commodity JVM. Our evaluation shows a dramatic improvement on performance over the state-of-the-art, with a speedup of 2 to 46 times, and high efficiency in sharing computations."},{"title":"Beyond Testing Configurable Systems: Applying Variational Execution to Automatic Program Repair and Higher Order Mutation Testing","authors":["Chu-Pan Wong","Jens Meinicke","Christian K\xe4stner"],"proceeding":"Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE-NIER)","year":"2018","publisher":"ACM","location":"Lake Buena Vista, FL, USA.","pages":"pages 749-753","doi":"https://doi.org/10.1145/3236024.3264837","pdf":"https://www.cs.cmu.edu/~chupanw/papers/fsenier18.pdf","abstract":"Generate-and-validate automatic program repair and higher order mutation testing often use search-based techniques to find optimal or good enough solutions in huge search spaces. As search spaces continue to grow, finding solutions that require interactions of multiple changes can become challenging. To tackle the huge search space, we propose to use variational execution. Variational execution has been shown to be effective in exhaustively exploring variations and identifying interactions in a huge but often finite configuration space. The key idea is to encode alternatives in the search space as variations and use variational execution as a black-box technique to generate useful insights so that existing search heuristics can be informed. We show that this idea is promising and identify criteria for problems in which variational execution is a promising tool, which may be useful to identify further applications."},{"title":"Understanding Differences among Executions with Variational Traces","authors":["Jens Meinicke","Chu-Pan Wong","Christian K\xe4stner","Gunter Saake"],"proceeding":"arXiv","year":"2018","arXiv":"https://arxiv.org/abs/1807.03837","abstract":"One of the main challenges of debugging is to understand why the program fails for certain inputs but succeeds for others. This becomes especially difficult if the fault is caused by an interaction of multiple inputs. To debug such interaction faults, it is necessary to understand the individual effect of the input, how these inputs interact and how these interactions cause the fault. The differences between two execution traces can explain why one input behaves differently than the other. We propose to compare execution traces of all input options to derive explanations of the behavior of all options and interactions among them. To make the relevant information stand out, we represent them as variational traces that concisely represents control-flow and data-flow differences among multiple concrete traces. While variational traces can be obtained from brute-force execution of all relevant inputs, we use variational execution to scale the generation of variational traces to the exponential space of possible inputs. We further provide an Eclipse plugin Varviz that enables users to use variational traces for debugging and navigation. In a user study, we show that users of variational traces are more than twice as fast to finish debugging tasks than users of the standard Eclipse debugger. We further show that variational traces can be scaled to programs with many options."},{"title":"A Choice of Variational Stacks: Exploring Variational Data Structures","authors":["Meng Meng","Jens Meinicke","Chu-Pan Wong","Eric Walkingshaw","Christian K\xe4stner"],"year":"2017","publisher":"ACM","proceeding":"Proceedings of the Eleventh International Workshop on Variability Modelling of Software-Intensive Systems (VaMoS)","location":"Eindhoven, Netherlands.","pages":"pages 28-35","doi":"https://doi.org/10.1145/3023956.3023966","pdf":"https://www.cs.cmu.edu/~chupanw/papers/vamos17.pdf","abstract":"Many applications require not only representing variability in software and data, but also computing with it. To do so efficiently requires variational data structures that make the variability explicit in the underlying data and the operations used to manipulate it. Variational data structures have been developed ad hoc for many applications, but there is little general understanding of how to design them or what tradeoffs exist among them. In this paper, we strive for a more systematic exploration and analysis of a variational data structure. We want to know how different design decisions affect the performance and scalability of a variational data structure, and what properties of the underlying data and operation sequences need to be considered. Specifically, we study several alternative designs of a variational stack, a data structure that supports efficiently representing and computing with multiple variants of a plain stack, and that is a common building block in many algorithms. The different variational stacks are presented as a small product line organized by three design decisions. We analyze how these design decisions affect the performance of a variational stack with different usage profiles. Finally, we evaluate how these design decisions affect the performance of the variational stack in a real-world scenario: in the interpreter VarexJ when executing real software containing variability."},{"title":"On Essential Configuration Complexity: Measuring Interactions in Highly-Configurable Systems","authors":["Jens Meinicke","Chu-Pan Wong","Christian K\xe4stner","Thomas Th\xfcm","Gunter Saake"],"year":"2016","publisher":"ACM","proceeding":"Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering (ASE)","pages":"pages 483\u2013494","location":"Singapore, Singapore.","doi":"https://doi.org/10.1145/2970276.2970322","pdf":"https://www.cs.cmu.edu/~chupanw/papers/ase16.pdf","abstract":"Quality assurance for highly-configurable systems is challenging due to the exponentially growing configuration space. Interactions among multiple options can lead to surprising behaviors, bugs, and security vulnerabilities. Analyzing all configurations systematically might be possible though if most options do not interact or interactions follow specific patterns that can be exploited by analysis tools. To better understand interactions in practice, we analyze program traces to characterize and identify where interactions occur on control flow and data. To this end, we developed a dynamic analysis for Java based on variability-aware execution and monitor executions of multiple small to medium-sized programs. We find that the essential configuration complexity of these programs is indeed much lower than the combinatorial explosion of the configuration space indicates. However, we also discover that the interaction characteristics that allow scalable and complete analyses are more nuanced than what is exploited by existing state-of-the-art quality assurance strategies."},{"title":"A Deeper Look into Bug Fixes: Patterns, Replacements, Deletions, and Additions","authors":["Mauricio Soto","Ferdian Thung","Chu-Pan Wong","Claire Le Goues","David Lo"],"year":"2016","publisher":"ACM","doi":"https://doi.org/10.1145/2901739.2903495","proceeding":"Proceedings of the 13th International Conference on Mining Software Repositories (MSR)","pages":"pages 512\u2013515","location":"Austin, Texas, USA.","pdf":"https://www.cs.cmu.edu/~chupanw/papers/msr16.pdf","abstract":"Many implementations of research techniques that automatically repair software bugs target programs written in C. Work that targets Java often begins from or compares to direct translations of such techniques to a Java context. However, Java and C are very different languages, and Java should be studied to inform the construction of repair approaches to target it. We conduct a large-scale study of bug-fixing commits in Java projects, focusing on assumptions underlying common search-based repair approaches. We make observations that can be leveraged to guide high quality automatic software repair to target Java specifically, including common and uncommon statement modifications in human patches and the applicability of previously-proposed patch construction operators in the Java context."},{"title":"Boosting Bug-Report-Oriented Fault Localization with Segmentation and Stack-Trace Analysis","authors":["Chu-Pan Wong","Yingfei Xiong","Hongyu Zhang","Dan Hao","Lu Zhang","Hong Mei"],"year":"2014","publisher":"IEEE","doi":"https://doi.org/10.1109/ICSME.2014.40","proceeding":"Proceedings of the 2014 IEEE International Conference on Software Maintenance and Evolution (ICSME)","pages":"pages 181\u2013190","location":"Victoria, BC, Canada.","pdf":"https://www.cs.cmu.edu/~chupanw/papers/icsme14.pdf","abstract":"To deal with post-release bugs, many software projects set up public bug repositories for users all over the world to report bugs that they have encountered. Recently, researchers have proposed various information retrieval based approaches to localizing faults based on bug reports. In these approaches, source files are processed as single units, where noise in large files may affect the accuracy of fault localization. Furthermore, bug reports often contain stack-trace information, but existing approaches often treat this information as plain text. In this paper, we propose to use segmentation and stack-trace analysis to improve the performance of bug localization. Specifically, given a bug report, we divide each source code file into a series of segments and use the segment most similar to the bug report to represent the file. We also analyze the bug report to identify possible faulty files in a stack trace and favor these files in our retrieval. According to our empirical results, our approach is able to significantly improve Bug Locator, a representative fault localization approach, on all the three software projects (i.e., Eclipse, AspectJ, and SWT) used in our empirical evaluation. Furthermore, segmentation and stack-trace analysis are complementary to each other for boosting the performance of bug-report-oriented fault localization."}]')},24:function(e,t,a){},26:function(e,t,a){},31:function(e,t,a){"use strict";a.r(t);var i=a(0),n=a.n(i),s=a(7),o=a.n(s),r=(a(24),a(25),a(26),a.p+"static/media/me.e3245fd0.jpg"),c=a(47),l=a(36),h=a(37),d=a(38),u=a(9),p=a(1);function g(){return Object(p.jsxs)(p.Fragment,{children:[Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-1"}),Object(p.jsx)("div",{className:"col-md-10 name",children:Object(p.jsx)("h1",{children:"Chu-Pan Wong"})})]}),Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-1",children:Object(p.jsx)(u.a,{})}),Object(p.jsx)("div",{className:"col-md-10",children:Object(p.jsx)("p",{children:"Research Scientist at Meta"})})]}),Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-1",children:Object(p.jsx)(l.a,{})}),Object(p.jsx)("div",{className:"col-md-10",children:Object(p.jsx)("p",{children:"Menlo Park"})})]}),Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-1",children:Object(p.jsx)(h.a,{})}),Object(p.jsx)("div",{className:"col-md-10",children:Object(p.jsx)("p",{children:"chupanw AT alumni.cmu.edu"})})]}),Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-1",children:Object(p.jsx)(d.a,{})}),Object(p.jsx)("div",{className:"col-md-10",children:Object(p.jsx)("a",{href:"https://github.com/chupanw",target:"_blank",rel:"noreferrer",children:Object(p.jsx)("p",{children:"chupanw"})})})]}),Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-1",children:Object(p.jsx)(u.b,{})}),Object(p.jsx)("div",{className:"col-md-10",children:Object(p.jsx)(f,{})})]})]})}function f(){return Object(p.jsxs)(p.Fragment,{children:[Object(p.jsx)(c.a,{variant:"success",className:"btn-sm icon",children:"Program Analysis"}),Object(p.jsx)(c.a,{variant:"success",className:"btn-sm icon",children:"Privacy"}),Object(p.jsx)(c.a,{variant:"success",className:"btn-sm icon",children:"SE for AI"}),Object(p.jsx)(c.a,{variant:"success",className:"btn-sm icon",children:"Software Engineering"})]})}var m=function(){return Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"profile col-md-4",children:Object(p.jsx)("img",{className:"rounded-circle",src:r,alt:"Chu-Pan Wong",width:300})}),Object(p.jsx)("div",{className:"col-md-8",children:Object(p.jsx)(g,{})})]})},b=a(45),j=a(16),v=a(18),y=a(48),w=a(46),x=a(39),O=a(40),S=a(41),E=a(42),C=a(43),k=a(44);function I(){return Object(p.jsxs)("span",{className:"iconSec",children:[Object(p.jsx)(x.a,{})," PUBLICATIONS"]})}function A(e){var t,a=e.title,i=e.authors,n=e.proceeding,s=e.location,o=e.year,r=e.publisher,l=e.pdf,h=e.abstract,d=e.doi,u=e.video,g=e.arXiv,f=e.pages,m=Object(p.jsx)("a",{href:"https://www.cs.cmu.edu/~ckaestne/",target:"_blank",rel:"noreferrer",children:"Christian K\xe4stner"}),b=Object(p.jsx)("a",{href:"https://clairelegoues.com/",target:"_blank",rel:"noreferrer",children:"Claire Le Goues"}),j=Object(p.jsx)("a",{href:"https://heather.miller.am/",target:"_blank",rel:"noreferrer",children:"Heather Miller"}),v=Object(p.jsx)("a",{href:"https://www.comp.nus.edu.sg/~abhik/",target:"_blank",rel:"noreferrer",children:"Abhik Roychoudhury"}),x=Object(p.jsxs)(y.a,{className:"my-popover",children:[Object(p.jsx)(y.a.Title,{as:"h3",children:a}),Object(p.jsxs)(y.a.Content,{children:[" ",h," "]})]});return t=n.startsWith("Proceedings")?Object(p.jsxs)("td",{children:[" ",i.join(", "),". ",o,". ",Object(p.jsx)("b",{children:a}),". In ",Object(p.jsx)("i",{children:n}),", ",f,". ",s," ",r,". "]}):Object(p.jsxs)("td",{children:[i.join(", "),". ",o,". ",Object(p.jsx)("b",{children:a}),". ",Object(p.jsx)("i",{children:n}),"."]}),Object(p.jsxs)(p.Fragment,{children:[Object(p.jsx)("tr",{children:t}),n.startsWith("PhD Dissertation")&&Object(p.jsxs)("tr",{children:["Committee members: ",m,", ",b,", ",j,", ",v,"."]}),Object(p.jsxs)("tr",{children:[Object(p.jsx)(w.a,{trigger:"click",rootClose:!0,placement:"bottom",overlay:x,children:Object(p.jsxs)(c.a,{variant:"primary",className:"btn-sm icon",children:[Object(p.jsx)(O.a,{})," Abstract"]})}),"undefined"!==typeof l&&Object(p.jsx)("a",{href:l,target:"_blank",rel:"noreferrer",children:Object(p.jsxs)(c.a,{variant:"success",className:"btn-sm icon",children:[Object(p.jsx)(S.a,{})," PDF"]})}),"undefined"!==typeof u&&Object(p.jsx)("a",{href:u,target:"_blank",rel:"noreferrer",children:Object(p.jsxs)(c.a,{variant:"info",className:"btn-sm icon",children:[Object(p.jsx)(E.a,{})," Video"]})}),"undefined"!==typeof d&&Object(p.jsx)("a",{href:d,target:"_blank",rel:"noreferrer",children:Object(p.jsxs)(c.a,{variant:"info",className:"btn-sm icon",children:[Object(p.jsx)(C.a,{})," DOI"]})}),"undefined"!==typeof g&&Object(p.jsx)("a",{href:g,target:"_blank",rel:"noreferrer",children:Object(p.jsxs)(c.a,{variant:"info",className:"btn-sm icon",children:[Object(p.jsx)(k.a,{})," arXiv"]})})]})]})}var M=function(e){var t=e.publications;return Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-4",children:Object(p.jsx)(I,{})}),Object(p.jsx)("div",{className:"col-md-8 sec",children:Object(p.jsx)("table",{children:t.map((function(e){return Object(p.jsx)(A,Object(v.a)({},e))}))})})]})};function P(){return Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-4",children:Object(p.jsx)(T,{})}),Object(p.jsx)("div",{className:"col-md-8 sec",children:Object(p.jsx)(N,{})})]})}function N(){return Object(p.jsxs)(p.Fragment,{children:[Object(p.jsx)("h4",{children:"Reviewer"}),Object(p.jsx)("p",{children:"TSE 2021, STVR 2021, TOSEM 2021"}),Object(p.jsx)("h4",{children:"Sub-Reviewer"}),Object(p.jsx)("p",{children:"ASE 2020, ICSE 2020, FSE 2019, ASE 2019, ICSE 2018, ICSE 2017, FSE 2017, ASE 2017, ASE 2015"}),Object(p.jsx)("h4",{children:"Student Volunteer"}),Object(p.jsx)("p",{children:"SPLASH 2015"})]})}function T(){return Object(p.jsxs)("span",{className:"iconSec",children:[Object(p.jsx)(u.c,{})," SERVICE"]})}var F=function(){return Object(p.jsxs)("div",{children:[Object(p.jsx)(W,{}),Object(p.jsx)(M,{publications:j}),Object(p.jsx)(P,{})]})};function W(){var e=Object(p.jsx)("a",{href:"https://www.cs.cmu.edu/~ckaestne/",target:"_blank",rel:"noreferrer",children:"Christian K\xe4stner"}),t=Object(p.jsx)("a",{href:"www.cmu.edu",children:"Carnegie Mellon University"}),a=Object(p.jsx)("a",{href:"www.pku.edu.cn",children:"Peking University"});return Object(p.jsxs)("div",{className:"row",children:[Object(p.jsx)("div",{className:"col-md-4",children:Object(p.jsx)(J,{})}),Object(p.jsxs)("div",{className:"col-md-8 sec",children:[Object(p.jsx)("p",{children:"I'm Chu-Pan Wong (\u9ec4\u67f1\u5f6c in Cantonese). I am broadly interested in developing software tools and systems for improving software quality and developer productivity. Among others, I have developed approaches to efficiently explore large search spaces of automatic program repair and higher-order mutation testing in the variational execution project."}),Object(p.jsxs)("p",{children:["I completed my PhD in 2021 at ",t,", where I had the pleasure to work with my advisor Professor ",e,". I received my Bachelor's degree in Computer Science from ",a,". Currently, I explore interesting research ideas in an industrial setting."]})]}),Object(p.jsx)("hr",{})]})}function J(){return Object(p.jsxs)("span",{className:"iconSec",children:[Object(p.jsx)(b.a,{})," ABOUT ME"]})}var V=function(){return Object(p.jsxs)("div",{className:"container body",children:[Object(p.jsx)(m,{}),Object(p.jsx)("div",{className:"row",children:Object(p.jsx)(F,{})})]})},z=function(e){e&&e instanceof Function&&a.e(3).then(a.bind(null,49)).then((function(t){var a=t.getCLS,i=t.getFID,n=t.getFCP,s=t.getLCP,o=t.getTTFB;a(e),i(e),n(e),s(e),o(e)}))};o.a.render(Object(p.jsx)(n.a.StrictMode,{children:Object(p.jsx)(V,{})}),document.getElementById("root")),z()}},[[31,1,2]]]);
//# sourceMappingURL=main.1fba3d9e.chunk.js.map